Shader "Custom/EsportPBRShaderGraph"
{
	Properties
	{
		_Amount("Amount", Float) = 0.1

	}
		SubShader
	{
		Tags
		{
			"RenderPipeline" = "LightweightPipeline"
			"RenderType" = "Opaque"
			"Queue" = "Geometry+0"
		}
		Pass
		{
			Tags{"LightMode" = "LightweightForward"}

			// Material options generated by graph

			Blend One Zero

			Cull Back

			ZTest LEqual

			ZWrite On

			HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		// -------------------------------------
		// Lightweight Pipeline keywords
		#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
		#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
		#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
		#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
		#pragma multi_compile _ _SHADOWS_SOFT
		#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE

		// -------------------------------------
		// Unity defined keywords
		#pragma multi_compile _ DIRLIGHTMAP_COMBINED
		#pragma multi_compile _ LIGHTMAP_ON
		#pragma multi_compile_fog

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex vert
		#pragma fragment frag

		// Defines generated by graph

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float _Amount;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 WorldSpaceNormal;
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			float3 ObjectSpacePosition;
		};


		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}


	inline float unity_noise_randomValue(float2 uv)
	{
		return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
	}

	inline float unity_noise_interpolate(float a, float b, float t)
	{
		return (1.0 - t)*a + (t*b);
	}


	inline float unity_valueNoise(float2 uv)
	{
		float2 i = floor(uv);
		float2 f = frac(uv);
		f = f * f * (3.0 - 2.0 * f);

		uv = abs(frac(uv) - 0.5);
		float2 c0 = i + float2(0.0, 0.0);
		float2 c1 = i + float2(1.0, 0.0);
		float2 c2 = i + float2(0.0, 1.0);
		float2 c3 = i + float2(1.0, 1.0);
		float r0 = unity_noise_randomValue(c0);
		float r1 = unity_noise_randomValue(c1);
		float r2 = unity_noise_randomValue(c2);
		float r3 = unity_noise_randomValue(c3);

		float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
		float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
		float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
		return t;
	}
		void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
		{
			float t = 0.0;

			float freq = pow(2.0, float(0));
			float amp = pow(0.5, float(3 - 0));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(1));
			amp = pow(0.5, float(3 - 1));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(2));
			amp = pow(0.5, float(3 - 2));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			Out = t;
		}

		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}


	inline float2 unity_voronoi_noise_randomVector(float2 UV, float offset)
	{
		float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
		UV = frac(sin(mul(UV, m)) * 46839.32);
		return float2(sin(UV.y*+offset)*0.5 + 0.5, cos(UV.x*offset)*0.5 + 0.5);
	}

		void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
		{
			float2 g = floor(UV * CellDensity);
			float2 f = frac(UV * CellDensity);
			float t = 8.0;
			float3 res = float3(8.0, 0.0, 0.0);

			for (int y = -1; y <= 1; y++)
			{
				for (int x = -1; x <= 1; x++)
				{
					float2 lattice = float2(x,y);
					float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
					float d = distance(lattice + offset, f);

					if (d < res.x)
					{

						res = float3(d, offset.x, offset.y);
						Out = res.x;
						Cells = res.y;

					}
				}

			}

		}

		void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
		{
			Out = A * B;
		}

		void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_4A2ACA1D_Out = _Amount;
			float3 _Add_70455956_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_70455956_Out);
			float _SimpleNoise_1D9097CC_Out;
			Unity_SimpleNoise_float((_Add_70455956_Out.xy), 100, _SimpleNoise_1D9097CC_Out);
			float _Multiply_4A5B08EC_Out;
			Unity_Multiply_float(_Property_4A2ACA1D_Out, _SimpleNoise_1D9097CC_Out, _Multiply_4A5B08EC_Out);

			float3 _Multiply_E8A91C0E_Out;
			Unity_Multiply_float(IN.WorldSpaceNormal, (_Multiply_4A5B08EC_Out.xxx), _Multiply_E8A91C0E_Out);

			float3 _Add_F02930FF_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, _Multiply_E8A91C0E_Out, _Add_F02930FF_Out);
			description.Position = _Add_F02930FF_Out;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Normal;
			float3 Emission;
			float Metallic;
			float Smoothness;
			float Occlusion;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 Color_36BD1B31 = IsGammaSpace() ? float4(0.003680706, 0, 1, 0) : float4(SRGBToLinear(float3(0.003680706, 0, 1)), 0);
			float3 _Add_F4CCDD5B_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_F4CCDD5B_Out);
			float _Voronoi_37D3A711_Out;
			float _Voronoi_37D3A711_Cells;
			Unity_Voronoi_float((_Add_F4CCDD5B_Out.xy), 2, 5, _Voronoi_37D3A711_Out, _Voronoi_37D3A711_Cells);
			float4 Color_D4C80021 = IsGammaSpace() ? float4(0, 0.596261, 2, 0) : float4(SRGBToLinear(float3(0, 0.596261, 2)), 0);
			float4 _Multiply_6CBC141D_Out;
			Unity_Multiply_float((_Voronoi_37D3A711_Out.xxxx), Color_D4C80021, _Multiply_6CBC141D_Out);

			float3 _Add_2C887A53_Out;
			Unity_Add_float3(_Add_F4CCDD5B_Out, (_Time.y.xxx), _Add_2C887A53_Out);
			float _SimpleNoise_E6500F35_Out;
			Unity_SimpleNoise_float((_Add_2C887A53_Out.xy), 10, _SimpleNoise_E6500F35_Out);
			float4 _Multiply_F75A645B_Out;
			Unity_Multiply_float(_Multiply_6CBC141D_Out, (_SimpleNoise_E6500F35_Out.xxxx), _Multiply_F75A645B_Out);

			float _Property_7BFA902D_Out = _Amount;
			float4 _Lerp_EF368DEE_Out;
			Unity_Lerp_float4(Color_36BD1B31, _Multiply_F75A645B_Out, (_Property_7BFA902D_Out.xxxx), _Lerp_EF368DEE_Out);
			surface.Albedo = IsGammaSpace() ? float3(0.5019608, 0.5019608, 0.5019608) : SRGBToLinear(float3(0.5019608, 0.5019608, 0.5019608));
			surface.Normal = IN.TangentSpaceNormal;
			surface.Emission = (_Lerp_EF368DEE_Out.xyz);
			surface.Metallic = 0;
			surface.Smoothness = 0.5;
			surface.Occlusion = 1;
			surface.Alpha = 1;
			surface.AlphaClipThreshold = 0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct GraphVertexOutput
		{
			float4 clipPos                : SV_POSITION;
			DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
			half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
			float4 shadowCoord            : TEXCOORD2;

			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv1 : TEXCOORD8;

			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
		};

		GraphVertexOutput vert(GraphVertexInput v)
		{
			GraphVertexOutput o = (GraphVertexOutput)0;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv1 = v.texcoord1;
			float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

			VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

			// Vertex description inputs defined by graph
			vdi.WorldSpaceNormal = WorldSpaceNormal;
			vdi.ObjectSpacePosition = ObjectSpacePosition;

			VertexDescription vd = PopulateVertexData(vdi);
			v.vertex.xyz = vd.Position;

			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv1 = uv1;

			float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

			VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);

			// We either sample GI from lightmap or SH.
			// Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
			// see DECLARE_LIGHTMAP_OR_SH macro.
			// The following funcions initialize the correct variable with correct data
			OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
			OUTPUT_SH(lwWNormal, o.vertexSH);

			half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
			half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
			o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
			o.clipPos = vertexInput.positionCS;

		#ifdef _MAIN_LIGHT_SHADOWS
			o.shadowCoord = GetShadowCoord(vertexInput);
		#endif
			return o;
		}

		half4 frag(GraphVertexOutput IN) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(IN);

		// Pixel transformations performed by graph
		float3 WorldSpacePosition = IN.WorldSpacePosition;
		float3 WorldSpaceNormal = IN.WorldSpaceNormal;
		float3 WorldSpaceTangent = IN.WorldSpaceTangent;
		float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
		float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
		float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
		float4 uv1 = IN.uv1;
		float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
		surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
		surfaceInput.ObjectSpacePosition = ObjectSpacePosition;

		SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Specular = float3(0, 0, 0);
		float Metallic = 1;
		float3 Normal = float3(0, 0, 1);
		float3 Emission = 0;
		float Smoothness = 0.5;
		float Occlusion = 1;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
		Albedo = surf.Albedo;
		Normal = surf.Normal;
		Emission = surf.Emission;
		Metallic = surf.Metallic;
		Smoothness = surf.Smoothness;
		Occlusion = surf.Occlusion;
		Alpha = surf.Alpha;
		AlphaClipThreshold = surf.AlphaClipThreshold;

		InputData inputData;
		inputData.positionWS = WorldSpacePosition;

#ifdef _NORMALMAP
		inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
#else
	#if !SHADER_HINT_NICE_QUALITY
		inputData.normalWS = WorldSpaceNormal;
	#else
		inputData.normalWS = normalize(WorldSpaceNormal);
	#endif
#endif

#if !SHADER_HINT_NICE_QUALITY
		// viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
		inputData.viewDirectionWS = WorldSpaceViewDirection;
#else
		inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
#endif

		inputData.shadowCoord = IN.shadowCoord;

		inputData.fogCoord = IN.fogFactorAndVertexLight.x;
		inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
		inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

		half4 color = LightweightFragmentPBR(
			inputData,
			Albedo,
			Metallic,
			Specular,
			Smoothness,
			Occlusion,
			Emission,
			Alpha);

		// Computes fog factor per-vertex
		color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

#if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return color;
	}

	ENDHLSL
}
Pass
{
	Name "ShadowCaster"
	Tags{"LightMode" = "ShadowCaster"}

	ZWrite On ZTest LEqual

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex ShadowPassVertex
		#pragma fragment ShadowPassFragment

		// Defines generated by graph

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float _Amount;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 WorldSpaceNormal;
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			float3 ObjectSpacePosition;
		};


		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}


	inline float unity_noise_randomValue(float2 uv)
	{
		return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
	}

	inline float unity_noise_interpolate(float a, float b, float t)
	{
		return (1.0 - t)*a + (t*b);
	}


	inline float unity_valueNoise(float2 uv)
	{
		float2 i = floor(uv);
		float2 f = frac(uv);
		f = f * f * (3.0 - 2.0 * f);

		uv = abs(frac(uv) - 0.5);
		float2 c0 = i + float2(0.0, 0.0);
		float2 c1 = i + float2(1.0, 0.0);
		float2 c2 = i + float2(0.0, 1.0);
		float2 c3 = i + float2(1.0, 1.0);
		float r0 = unity_noise_randomValue(c0);
		float r1 = unity_noise_randomValue(c1);
		float r2 = unity_noise_randomValue(c2);
		float r3 = unity_noise_randomValue(c3);

		float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
		float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
		float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
		return t;
	}
		void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
		{
			float t = 0.0;

			float freq = pow(2.0, float(0));
			float amp = pow(0.5, float(3 - 0));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(1));
			amp = pow(0.5, float(3 - 1));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(2));
			amp = pow(0.5, float(3 - 2));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			Out = t;
		}

		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}


	inline float2 unity_voronoi_noise_randomVector(float2 UV, float offset)
	{
		float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
		UV = frac(sin(mul(UV, m)) * 46839.32);
		return float2(sin(UV.y*+offset)*0.5 + 0.5, cos(UV.x*offset)*0.5 + 0.5);
	}

		void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
		{
			float2 g = floor(UV * CellDensity);
			float2 f = frac(UV * CellDensity);
			float t = 8.0;
			float3 res = float3(8.0, 0.0, 0.0);

			for (int y = -1; y <= 1; y++)
			{
				for (int x = -1; x <= 1; x++)
				{
					float2 lattice = float2(x,y);
					float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
					float d = distance(lattice + offset, f);

					if (d < res.x)
					{

						res = float3(d, offset.x, offset.y);
						Out = res.x;
						Cells = res.y;

					}
				}

			}

		}

		void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
		{
			Out = A * B;
		}

		void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_4A2ACA1D_Out = _Amount;
			float3 _Add_70455956_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_70455956_Out);
			float _SimpleNoise_1D9097CC_Out;
			Unity_SimpleNoise_float((_Add_70455956_Out.xy), 100, _SimpleNoise_1D9097CC_Out);
			float _Multiply_4A5B08EC_Out;
			Unity_Multiply_float(_Property_4A2ACA1D_Out, _SimpleNoise_1D9097CC_Out, _Multiply_4A5B08EC_Out);

			float3 _Multiply_E8A91C0E_Out;
			Unity_Multiply_float(IN.WorldSpaceNormal, (_Multiply_4A5B08EC_Out.xxx), _Multiply_E8A91C0E_Out);

			float3 _Add_F02930FF_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, _Multiply_E8A91C0E_Out, _Add_F02930FF_Out);
			description.Position = _Add_F02930FF_Out;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Emission;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 Color_36BD1B31 = IsGammaSpace() ? float4(0.003680706, 0, 1, 0) : float4(SRGBToLinear(float3(0.003680706, 0, 1)), 0);
			float3 _Add_F4CCDD5B_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_F4CCDD5B_Out);
			float _Voronoi_37D3A711_Out;
			float _Voronoi_37D3A711_Cells;
			Unity_Voronoi_float((_Add_F4CCDD5B_Out.xy), 2, 5, _Voronoi_37D3A711_Out, _Voronoi_37D3A711_Cells);
			float4 Color_D4C80021 = IsGammaSpace() ? float4(0, 0.596261, 2, 0) : float4(SRGBToLinear(float3(0, 0.596261, 2)), 0);
			float4 _Multiply_6CBC141D_Out;
			Unity_Multiply_float((_Voronoi_37D3A711_Out.xxxx), Color_D4C80021, _Multiply_6CBC141D_Out);

			float3 _Add_2C887A53_Out;
			Unity_Add_float3(_Add_F4CCDD5B_Out, (_Time.y.xxx), _Add_2C887A53_Out);
			float _SimpleNoise_E6500F35_Out;
			Unity_SimpleNoise_float((_Add_2C887A53_Out.xy), 10, _SimpleNoise_E6500F35_Out);
			float4 _Multiply_F75A645B_Out;
			Unity_Multiply_float(_Multiply_6CBC141D_Out, (_SimpleNoise_E6500F35_Out.xxxx), _Multiply_F75A645B_Out);

			float _Property_7BFA902D_Out = _Amount;
			float4 _Lerp_EF368DEE_Out;
			Unity_Lerp_float4(Color_36BD1B31, _Multiply_F75A645B_Out, (_Property_7BFA902D_Out.xxxx), _Lerp_EF368DEE_Out);
			surface.Albedo = IsGammaSpace() ? float3(0.5019608, 0.5019608, 0.5019608) : SRGBToLinear(float3(0.5019608, 0.5019608, 0.5019608));
			surface.Emission = (_Lerp_EF368DEE_Out.xyz);
			surface.Alpha = 1;
			surface.AlphaClipThreshold = 0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct VertexOutput
		{
			float2 uv           : TEXCOORD0;
			float4 clipPos      : SV_POSITION;
			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv1 : TEXCOORD8;

			UNITY_VERTEX_INPUT_INSTANCE_ID
		};

		// x: global clip space bias, y: normal world space bias
		float4 _ShadowBias;
		float3 _LightDirection;

		VertexOutput ShadowPassVertex(GraphVertexInput v)
		{
			VertexOutput o;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv1 = v.texcoord1;
			float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

			VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

			// Vertex description inputs defined by graph
			vdi.WorldSpaceNormal = WorldSpaceNormal;
			vdi.ObjectSpacePosition = ObjectSpacePosition;

			VertexDescription vd = PopulateVertexData(vdi);
			v.vertex.xyz = vd.Position;

			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv1 = uv1;


			float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
			float3 normalWS = TransformObjectToWorldNormal(v.normal);

			float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
			float scale = invNdotL * _ShadowBias.y;

			// normal bias is negative since we want to apply an inset normal offset
			positionWS = normalWS * scale.xxx + positionWS;
			float4 clipPos = TransformWorldToHClip(positionWS);

			// _ShadowBias.x sign depens on if platform has reversed z buffer
			clipPos.z += _ShadowBias.x;

		#if UNITY_REVERSED_Z
			clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
		#else
			clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
		#endif
			o.clipPos = clipPos;

			return o;
		}

		half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
		{
			UNITY_SETUP_INSTANCE_ID(IN);

		// Pixel transformations performed by graph
		float3 WorldSpacePosition = IN.WorldSpacePosition;
		float3 WorldSpaceNormal = IN.WorldSpaceNormal;
		float3 WorldSpaceTangent = IN.WorldSpaceTangent;
		float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
		float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
		float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
		float4 uv1 = IN.uv1;
		float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
		surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
		surfaceInput.ObjectSpacePosition = ObjectSpacePosition;

		SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
		Albedo = surf.Albedo;
		Emission = surf.Emission;
		Alpha = surf.Alpha;
		AlphaClipThreshold = surf.AlphaClipThreshold;

 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return 0;
	}

	ENDHLSL
}

Pass
{
	Name "DepthOnly"
	Tags{"LightMode" = "DepthOnly"}

	ZWrite On
	ColorMask 0

		// Material options generated by graph
		Cull Back

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex vert
		#pragma fragment frag

		// Defines generated by graph

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float _Amount;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 WorldSpaceNormal;
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			float3 ObjectSpacePosition;
		};


		void Unity_Add_float3(float3 A, float3 B, out float3 Out)
		{
			Out = A + B;
		}


	inline float unity_noise_randomValue(float2 uv)
	{
		return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
	}

	inline float unity_noise_interpolate(float a, float b, float t)
	{
		return (1.0 - t)*a + (t*b);
	}


	inline float unity_valueNoise(float2 uv)
	{
		float2 i = floor(uv);
		float2 f = frac(uv);
		f = f * f * (3.0 - 2.0 * f);

		uv = abs(frac(uv) - 0.5);
		float2 c0 = i + float2(0.0, 0.0);
		float2 c1 = i + float2(1.0, 0.0);
		float2 c2 = i + float2(0.0, 1.0);
		float2 c3 = i + float2(1.0, 1.0);
		float r0 = unity_noise_randomValue(c0);
		float r1 = unity_noise_randomValue(c1);
		float r2 = unity_noise_randomValue(c2);
		float r3 = unity_noise_randomValue(c3);

		float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
		float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
		float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
		return t;
	}
		void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
		{
			float t = 0.0;

			float freq = pow(2.0, float(0));
			float amp = pow(0.5, float(3 - 0));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(1));
			amp = pow(0.5, float(3 - 1));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			freq = pow(2.0, float(2));
			amp = pow(0.5, float(3 - 2));
			t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

			Out = t;
		}

		void Unity_Multiply_float(float A, float B, out float Out)
		{
			Out = A * B;
		}

		void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
		{
			Out = A * B;
		}


	inline float2 unity_voronoi_noise_randomVector(float2 UV, float offset)
	{
		float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
		UV = frac(sin(mul(UV, m)) * 46839.32);
		return float2(sin(UV.y*+offset)*0.5 + 0.5, cos(UV.x*offset)*0.5 + 0.5);
	}

		void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
		{
			float2 g = floor(UV * CellDensity);
			float2 f = frac(UV * CellDensity);
			float t = 8.0;
			float3 res = float3(8.0, 0.0, 0.0);

			for (int y = -1; y <= 1; y++)
			{
				for (int x = -1; x <= 1; x++)
				{
					float2 lattice = float2(x,y);
					float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
					float d = distance(lattice + offset, f);

					if (d < res.x)
					{

						res = float3(d, offset.x, offset.y);
						Out = res.x;
						Cells = res.y;

					}
				}

			}

		}

		void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
		{
			Out = A * B;
		}

		void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
		{
			Out = lerp(A, B, T);
		}

		struct VertexDescription
		{
			float3 Position;
		};

		VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
		{
			VertexDescription description = (VertexDescription)0;
			float _Property_4A2ACA1D_Out = _Amount;
			float3 _Add_70455956_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_70455956_Out);
			float _SimpleNoise_1D9097CC_Out;
			Unity_SimpleNoise_float((_Add_70455956_Out.xy), 100, _SimpleNoise_1D9097CC_Out);
			float _Multiply_4A5B08EC_Out;
			Unity_Multiply_float(_Property_4A2ACA1D_Out, _SimpleNoise_1D9097CC_Out, _Multiply_4A5B08EC_Out);

			float3 _Multiply_E8A91C0E_Out;
			Unity_Multiply_float(IN.WorldSpaceNormal, (_Multiply_4A5B08EC_Out.xxx), _Multiply_E8A91C0E_Out);

			float3 _Add_F02930FF_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, _Multiply_E8A91C0E_Out, _Add_F02930FF_Out);
			description.Position = _Add_F02930FF_Out;
			return description;
		}

		struct SurfaceDescription
		{
			float3 Albedo;
			float3 Emission;
			float Alpha;
			float AlphaClipThreshold;
		};

		SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
		{
			SurfaceDescription surface = (SurfaceDescription)0;
			float4 Color_36BD1B31 = IsGammaSpace() ? float4(0.003680706, 0, 1, 0) : float4(SRGBToLinear(float3(0.003680706, 0, 1)), 0);
			float3 _Add_F4CCDD5B_Out;
			Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_F4CCDD5B_Out);
			float _Voronoi_37D3A711_Out;
			float _Voronoi_37D3A711_Cells;
			Unity_Voronoi_float((_Add_F4CCDD5B_Out.xy), 2, 5, _Voronoi_37D3A711_Out, _Voronoi_37D3A711_Cells);
			float4 Color_D4C80021 = IsGammaSpace() ? float4(0, 0.596261, 2, 0) : float4(SRGBToLinear(float3(0, 0.596261, 2)), 0);
			float4 _Multiply_6CBC141D_Out;
			Unity_Multiply_float((_Voronoi_37D3A711_Out.xxxx), Color_D4C80021, _Multiply_6CBC141D_Out);

			float3 _Add_2C887A53_Out;
			Unity_Add_float3(_Add_F4CCDD5B_Out, (_Time.y.xxx), _Add_2C887A53_Out);
			float _SimpleNoise_E6500F35_Out;
			Unity_SimpleNoise_float((_Add_2C887A53_Out.xy), 10, _SimpleNoise_E6500F35_Out);
			float4 _Multiply_F75A645B_Out;
			Unity_Multiply_float(_Multiply_6CBC141D_Out, (_SimpleNoise_E6500F35_Out.xxxx), _Multiply_F75A645B_Out);

			float _Property_7BFA902D_Out = _Amount;
			float4 _Lerp_EF368DEE_Out;
			Unity_Lerp_float4(Color_36BD1B31, _Multiply_F75A645B_Out, (_Property_7BFA902D_Out.xxxx), _Lerp_EF368DEE_Out);
			surface.Albedo = IsGammaSpace() ? float3(0.5019608, 0.5019608, 0.5019608) : SRGBToLinear(float3(0.5019608, 0.5019608, 0.5019608));
			surface.Emission = (_Lerp_EF368DEE_Out.xyz);
			surface.Alpha = 1;
			surface.AlphaClipThreshold = 0;
			return surface;
		}

		struct GraphVertexInput
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			float4 tangent : TANGENT;
			float4 texcoord1 : TEXCOORD1;
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};


		struct VertexOutput
		{
			float2 uv           : TEXCOORD0;
			float4 clipPos      : SV_POSITION;
			// Interpolators defined by graph
			float3 WorldSpacePosition : TEXCOORD3;
			float3 WorldSpaceNormal : TEXCOORD4;
			float3 WorldSpaceTangent : TEXCOORD5;
			float3 WorldSpaceBiTangent : TEXCOORD6;
			float3 WorldSpaceViewDirection : TEXCOORD7;
			half4 uv1 : TEXCOORD8;

			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
		};

		VertexOutput vert(GraphVertexInput v)
		{
			VertexOutput o = (VertexOutput)0;
			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, o);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

			// Vertex transformations performed by graph
			float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
			float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
			float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
			float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
			float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
			float4 uv1 = v.texcoord1;
			float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

			VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

			// Vertex description inputs defined by graph
			vdi.WorldSpaceNormal = WorldSpaceNormal;
			vdi.ObjectSpacePosition = ObjectSpacePosition;

			VertexDescription vd = PopulateVertexData(vdi);
			v.vertex.xyz = vd.Position;

			// Vertex shader outputs defined by graph
			o.WorldSpacePosition = WorldSpacePosition;
			o.WorldSpaceNormal = WorldSpaceNormal;
			o.WorldSpaceTangent = WorldSpaceTangent;
			o.WorldSpaceBiTangent = WorldSpaceBiTangent;
			o.WorldSpaceViewDirection = WorldSpaceViewDirection;
			o.uv1 = uv1;

			o.clipPos = TransformObjectToHClip(v.vertex.xyz);
			return o;
		}

		half4 frag(VertexOutput IN) : SV_TARGET
		{
			UNITY_SETUP_INSTANCE_ID(IN);

		// Pixel transformations performed by graph
		float3 WorldSpacePosition = IN.WorldSpacePosition;
		float3 WorldSpaceNormal = IN.WorldSpaceNormal;
		float3 WorldSpaceTangent = IN.WorldSpaceTangent;
		float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
		float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
		float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
		float4 uv1 = IN.uv1;
		float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
		surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
		surfaceInput.ObjectSpacePosition = ObjectSpacePosition;

		SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
		Albedo = surf.Albedo;
		Emission = surf.Emission;
		Alpha = surf.Alpha;
		AlphaClipThreshold = surf.AlphaClipThreshold;

 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return 0;
	}
	ENDHLSL
}

// This pass it not used during regular rendering, only for lightmap baking.
Pass
{
	Name "Meta"
	Tags{"LightMode" = "Meta"}

	Cull Off

	HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		#pragma vertex vert
		#pragma fragment frag

		float4 _MainTex_ST;

	// Defines generated by graph

	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

	#pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

		CBUFFER_START(UnityPerMaterial)
	float _Amount;
	CBUFFER_END


	struct VertexDescriptionInputs
	{
		float3 WorldSpaceNormal;
		float3 ObjectSpacePosition;
	};

	struct SurfaceDescriptionInputs
	{
		float3 TangentSpaceNormal;
		float3 ObjectSpacePosition;
	};


	void Unity_Add_float3(float3 A, float3 B, out float3 Out)
	{
		Out = A + B;
	}


inline float unity_noise_randomValue(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
}

inline float unity_noise_interpolate(float a, float b, float t)
{
	return (1.0 - t)*a + (t*b);
}


inline float unity_valueNoise(float2 uv)
{
	float2 i = floor(uv);
	float2 f = frac(uv);
	f = f * f * (3.0 - 2.0 * f);

	uv = abs(frac(uv) - 0.5);
	float2 c0 = i + float2(0.0, 0.0);
	float2 c1 = i + float2(1.0, 0.0);
	float2 c2 = i + float2(0.0, 1.0);
	float2 c3 = i + float2(1.0, 1.0);
	float r0 = unity_noise_randomValue(c0);
	float r1 = unity_noise_randomValue(c1);
	float r2 = unity_noise_randomValue(c2);
	float r3 = unity_noise_randomValue(c3);

	float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
	float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
	float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
	return t;
}
	void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
	{
		float t = 0.0;

		float freq = pow(2.0, float(0));
		float amp = pow(0.5, float(3 - 0));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(1));
		amp = pow(0.5, float(3 - 1));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(2));
		amp = pow(0.5, float(3 - 2));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		Out = t;
	}

	void Unity_Multiply_float(float A, float B, out float Out)
	{
		Out = A * B;
	}

	void Unity_Multiply_float(float3 A, float3 B, out float3 Out)
	{
		Out = A * B;
	}


inline float2 unity_voronoi_noise_randomVector(float2 UV, float offset)
{
	float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
	UV = frac(sin(mul(UV, m)) * 46839.32);
	return float2(sin(UV.y*+offset)*0.5 + 0.5, cos(UV.x*offset)*0.5 + 0.5);
}

	void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
	{
		float2 g = floor(UV * CellDensity);
		float2 f = frac(UV * CellDensity);
		float t = 8.0;
		float3 res = float3(8.0, 0.0, 0.0);

		for (int y = -1; y <= 1; y++)
		{
			for (int x = -1; x <= 1; x++)
			{
				float2 lattice = float2(x,y);
				float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
				float d = distance(lattice + offset, f);

				if (d < res.x)
				{

					res = float3(d, offset.x, offset.y);
					Out = res.x;
					Cells = res.y;

				}
			}

		}

	}

	void Unity_Multiply_float(float4 A, float4 B, out float4 Out)
	{
		Out = A * B;
	}

	void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
	{
		Out = lerp(A, B, T);
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		float _Property_4A2ACA1D_Out = _Amount;
		float3 _Add_70455956_Out;
		Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_70455956_Out);
		float _SimpleNoise_1D9097CC_Out;
		Unity_SimpleNoise_float((_Add_70455956_Out.xy), 100, _SimpleNoise_1D9097CC_Out);
		float _Multiply_4A5B08EC_Out;
		Unity_Multiply_float(_Property_4A2ACA1D_Out, _SimpleNoise_1D9097CC_Out, _Multiply_4A5B08EC_Out);

		float3 _Multiply_E8A91C0E_Out;
		Unity_Multiply_float(IN.WorldSpaceNormal, (_Multiply_4A5B08EC_Out.xxx), _Multiply_E8A91C0E_Out);

		float3 _Add_F02930FF_Out;
		Unity_Add_float3(IN.ObjectSpacePosition, _Multiply_E8A91C0E_Out, _Add_F02930FF_Out);
		description.Position = _Add_F02930FF_Out;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float4 Color_36BD1B31 = IsGammaSpace() ? float4(0.003680706, 0, 1, 0) : float4(SRGBToLinear(float3(0.003680706, 0, 1)), 0);
		float3 _Add_F4CCDD5B_Out;
		Unity_Add_float3(IN.ObjectSpacePosition, (_Time.y.xxx), _Add_F4CCDD5B_Out);
		float _Voronoi_37D3A711_Out;
		float _Voronoi_37D3A711_Cells;
		Unity_Voronoi_float((_Add_F4CCDD5B_Out.xy), 2, 5, _Voronoi_37D3A711_Out, _Voronoi_37D3A711_Cells);
		float4 Color_D4C80021 = IsGammaSpace() ? float4(0, 0.596261, 2, 0) : float4(SRGBToLinear(float3(0, 0.596261, 2)), 0);
		float4 _Multiply_6CBC141D_Out;
		Unity_Multiply_float((_Voronoi_37D3A711_Out.xxxx), Color_D4C80021, _Multiply_6CBC141D_Out);

		float3 _Add_2C887A53_Out;
		Unity_Add_float3(_Add_F4CCDD5B_Out, (_Time.y.xxx), _Add_2C887A53_Out);
		float _SimpleNoise_E6500F35_Out;
		Unity_SimpleNoise_float((_Add_2C887A53_Out.xy), 10, _SimpleNoise_E6500F35_Out);
		float4 _Multiply_F75A645B_Out;
		Unity_Multiply_float(_Multiply_6CBC141D_Out, (_SimpleNoise_E6500F35_Out.xxxx), _Multiply_F75A645B_Out);

		float _Property_7BFA902D_Out = _Amount;
		float4 _Lerp_EF368DEE_Out;
		Unity_Lerp_float4(Color_36BD1B31, _Multiply_F75A645B_Out, (_Property_7BFA902D_Out.xxxx), _Lerp_EF368DEE_Out);
		surface.Albedo = IsGammaSpace() ? float3(0.5019608, 0.5019608, 0.5019608) : SRGBToLinear(float3(0.5019608, 0.5019608, 0.5019608));
		surface.Emission = (_Lerp_EF368DEE_Out.xyz);
		surface.Alpha = 1;
		surface.AlphaClipThreshold = 0;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv1 : TEXCOORD8;

		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	};

	VertexOutput vert(GraphVertexInput v)
	{
		VertexOutput o = (VertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv1 = v.texcoord1;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv1 = uv1;

		o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST);
		return o;
	}

	half4 frag(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
	float4 uv1 = IN.uv1;
	float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;
	float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
	surfaceInput.ObjectSpacePosition = ObjectSpacePosition;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	   clip(Alpha - AlphaClipThreshold);
#endif

		MetaInput metaInput = (MetaInput)0;
		metaInput.Albedo = Albedo;
		metaInput.Emission = Emission;

		return MetaFragment(metaInput);
	}
	ENDHLSL
}
	}
		CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
		FallBack "Hidden/InternalErrorShader"
}
